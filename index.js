require('dotenv').config();
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const axios = require('axios');
const Redis = require('ioredis');
const cron = require('node-cron'); 

const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL); // Use Redis connection string
const app = express();
const PORT = process.env.PORT || 3000;
app.use(express.json());

// API to set the notification message
app.post('/api/set-message', async (req, res) => {
  const { message, id } = req.body;

  if (!message) {
    return res.status(400).json({ error: 'Message is required' });
  }

  try {
    let notification;

    if (id) {
      // Update or create if `id` is provided
      notification = await prisma.notification.upsert({
        where: { id },
        update: { message },
        create: { id, message },
      });
    } else {
      // Create a new notification with autogenerated `id`
      notification = await prisma.notification.create({
        data: { message },
      });
    }

    console.log(`Notification message set: ${notification.message}`);
    res.status(200).json({
      message: 'Notification message set successfully',
      id: notification.id, // Return the created or updated notification's ID
    });
  } catch (error) {
    console.error('Failed to set notification message:', error.message);
    res.status(500).json({ error: 'Failed to set notification message' });
  }
});

const MAX_MESSAGES_PER_SECOND = 20;
const PAGE_SIZE = 1000;// Define the number of users to fetch per page

const sendNotifications = async () => {
  const BATCH_SIZE = 300;
  const DELAY = 1000;

  try {
    let message = await redis.get('notification_message');
    if (!message) {
      const notification = await prisma.notification.findMany();
      if (!notification[0] || !notification[0].message) {
        console.error('Notification message is not set. Use /api/set-message first.');
        return;
      }
      message = notification[0].message;
      await redis.set('notification_message', message);
    }

    console.log("yaha tak pahch gy ahai ");

    let users;
    let page = 0;
    // let fetchedUsers;


      // Initialize counters
      let successCount = 0;
      let chatNotFoundCount = 0;
      let blockedCount = 0;
      let errorCount = 0;



    do {
      users = await prisma.user.findMany({
        skip: page * PAGE_SIZE,
        take: PAGE_SIZE,
      });

      const batches = [];


      for (let i = 0; i < users.length; i += MAX_MESSAGES_PER_SECOND) {
        batches.push(users.slice(i, i + MAX_MESSAGES_PER_SECOND));
    }



    for (const batch of batches) {
      const results = await Promise.all(batch.map(async user => {
          try {
              const result = await sendTelegramMessage(user.chatId, message);
              return result;
          } catch (error) {
              console.log(`Failed to send message to tgId: ${user.tgId}. Error: ${error.message}`);
              return 'error';
          }
      }));

      // Process the results
      for (const result of results) {
          if (result === 'success') {
              successCount++;
          } else if (result === 'chat_not_found') {
              chatNotFoundCount++;
          } else if (result === 'blocked') {
              blockedCount++;
          } else {
              errorCount++;
          }
      }

      console.log(`Sent batch, waiting 1 second...`);
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second between batches
  }


    console.log(`Processed page ${page + 1}`);;
      page++ 




    } while (users.length >0);

    console.log("Messages sent to all users successfully.");
    console.log(`Successfully sent messages: ${successCount}`);
    console.log(`Chat not found users: ${chatNotFoundCount}`);
    console.log(`Blocked users: ${blockedCount}`);
    console.log(`Other errors: ${errorCount}`);

    // console.log("ðŸš€ ~ sendNotifications ~ users:", users.length);


  } catch (error) {
    console.error('Error sending messages to users:', error);
  }
};



const sendTelegramMessage = async (tgId, message, image, buttonName) => {
  console.log("ðŸš€ ~ sendTelegramMessage ~ tgId:", tgId)
  try {
      // let miniAppLink = process.env.TG_MINI_APP_LINK;
          const textPayload = {
              chat_id: tgId,
              text: message,
              // reply_markup: {
              //     inline_keyboard: [
              //         [
              //             {
              //                 text: buttonName,
              //                 url: miniAppLink
              //             }
              //         ]
              //     ]
              // }
          };
          await axios.post(`${process.env.TELEGRAM_API_URL}/sendMessage`, textPayload);
          console.log(`Message with button sent to tgId: ${tgId}`);
    
      return 'success';
  } catch (error) {
      if (error.response) {
          const errorCode = error.response.data.error_code;
          const description = error.response.data.description;
          if (errorCode === 403) {
              console.error(`Bot was blocked by tgId: ${tgId}`);
              return 'blocked';
          } else if (errorCode === 400 && description.includes('chat not found')) {
              console.error(`Chat not found for tgId: ${tgId}`);
              return 'chat_not_found';
          } else if (errorCode === 400 && description.includes('user not found')) {
              console.error(`User not found for tgId: ${tgId}`);
              return 'chat_not_found';
          } else {
              console.error(`Failed to send message to tgId: ${tgId}`, error.response.data);
              return 'error';
          }
      } else {
          console.error(`Failed to send message to tgId: ${tgId}`, error.message);
          return 'error';
      }
  }
};



// Graceful shutdown on exit
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  await redis.quit();
  process.exit(0);
});


// Schedule cron job to send notifications every 3 hours
cron.schedule('0 */3 * * *', async () => {
  console.log('Cron job triggered: Sending notifications every 3 hours');
  await sendNotifications();
});

// Start the server
app.listen(PORT, '0.0.0.0', async () => {
  console.log(`Server is running on port ${PORT}`);
  // Trigger notifications immediately on deployment
  console.log('Triggering notifications on deployment...');
  await sendNotifications();
  
});
