require('dotenv').config();
const express = require('express');
const { PrismaClient } = require('@prisma/client');
const axios = require('axios');
const Redis = require('ioredis');
const cron = require('node-cron'); 

const prisma = new PrismaClient();
const redis = new Redis(process.env.REDIS_URL); // Use Redis connection string
const app = express();
const PORT = process.env.PORT || 3000;

app.use(express.json());

// API to set the notification message
app.post('/api/set-message', async (req, res) => {
  const { message, id } = req.body;

  if (!message) {
    return res.status(400).json({ error: 'Message is required' });
  }

  try {
    let notification;

    if (id) {
      // Update or create if `id` is provided
      notification = await prisma.notification.upsert({
        where: { id },
        update: { message },
        create: { id, message },
      });
    } else {
      // Create a new notification with autogenerated `id`
      notification = await prisma.notification.create({
        data: { message },
      });
    }

    console.log(`Notification message set: ${notification.message}`);
    res.status(200).json({
      message: 'Notification message set successfully',
      id: notification.id, // Return the created or updated notification's ID
    });
  } catch (error) {
    console.error('Failed to set notification message:', error.message);
    res.status(500).json({ error: 'Failed to set notification message' });
  }
});

const sendNotifications = async () => {
  const BATCH_SIZE = 30;
  const DELAY = 1000;

  try {
    let message = await redis.get('notification_message');
    if (!message) {
      const notification = await prisma.notification.findMany();
      if (!notification[0] || !notification[0].message) {
        console.error('Notification message is not set. Use /api/set-message first.');
        return;
      }
      message = notification[0].message;
      await redis.set('notification_message', message);
    }

    let users = await redis.get('users');
    if (!users) {
      users = await prisma.user.findMany();
      await redis.set('users', JSON.stringify(users));
    } else {
      users = JSON.parse(users);
    }

    const totalUsers = users.length;
    let failedCount = 0;

    console.log(`Sending notifications to ${totalUsers} users...`);

    for (let i = 0; i < totalUsers; i += BATCH_SIZE) {
      const batch = users.slice(i, i + BATCH_SIZE);

      await Promise.all(
        batch.map(async user => {
          try {
            await axios.post(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
              chat_id: user.chatId,
              text: message,
              disable_notification: false,
            });
          } catch (err) {
            console.error(`Failed to send to ${user.chatId}:`, err.message);
            console.log(`Failed to send to ${user.chatId}:`, err);
            failedCount += 1;
          }
        })
      );
      

      console.log(`Batch ${i / BATCH_SIZE + 1} sent`);

      if (i + BATCH_SIZE < totalUsers) {
        await new Promise(resolve => setTimeout(resolve, DELAY));
      }
    }

    console.log(`Notifications sent: ${totalUsers - failedCount}`);
    console.log(`Failed messages: ${failedCount}`);
  } catch (error) {
    console.error('Error sending notifications:', error);
  }
};



// API to send batch notifications
app.post('/api/send-notifications', async (req, res) => {
  const BATCH_SIZE = 30; // Telegram rate limit
  const DELAY = 1000; // Delay in ms between batches

  try {
    // Fetch the message from Redis or the Notification table
    let message = await redis.get('notification_message');
    if (!message) {
      const notification = await prisma.notification.findMany();
      console.log("ðŸš€ ~ app.post ~ notification:", notification)
      console.log("ðŸš€ ~ app.post ~ notification:", notification[0].id)
      console.log("ðŸš€ ~ app.post ~ notification:", notification[0].message)
      if (!notification[0].id || !notification[0].message) {
        return res.status(400).json({ error: 'Notification message is not set. Use /api/set-message first.' });
      }
      message = notification[0].message;
      await redis.set('notification_message', message); // Cache the message
    }

    // Fetch users from Redis or the database
    let users = await redis.get('users');
    if (!users) {
      users = await prisma.user.findMany();
      await redis.set('users', JSON.stringify(users), 'EX', 4 * 24 * 60 * 60); 
    } else {
      users = JSON.parse(users);
    }

    const totalUsers = users.length;
    let failedCount = 0; 
    console.log(`Sending notifications to ${totalUsers} users...`);

    for (let i = 0; i < totalUsers; i += BATCH_SIZE) {
      const batch = users.slice(i, i + BATCH_SIZE);

      // Send notifications to the batch
      await Promise.all(
        batch.map(async user => {
          try {
            await axios.post(`https://api.telegram.org/bot${process.env.TELEGRAM_BOT_TOKEN}/sendMessage`, {
              chat_id: user.chatId,
              text: message,
              disable_notification: false,
            });
          } catch (err) {
            // console.error(`Failed to send to ${user.chatId}:`, err);
            // console.log(`Failed to send to ${user.chatId}:`, err);
            failedCount += 1;
          }
        })
      );
      

      console.log(`Batch ${i / BATCH_SIZE + 1} sent`);

      // Delay before the next batch
      if (i + BATCH_SIZE < totalUsers) {
        await new Promise(resolve => setTimeout(resolve, DELAY));
      }
    }

    console.log(`Notifications sent: ${totalUsers - failedCount}`);
    console.log(`Failed messages: ${failedCount}`);

    res.status(200).json({ message: 'Notifications sent successfully' });
  } catch (error) {
    // console.error('Error sending notifications:', error);
    
    res.status(500).json({ error: 'Failed to send notifications' });
  }
});

// Graceful shutdown on exit
process.on('SIGINT', async () => {
  console.log('Shutting down gracefully...');
  await prisma.$disconnect();
  await redis.quit();
  process.exit(0);
});


// Schedule cron job to send notifications every 3 hours
cron.schedule('0 */3 * * *', async () => {
  console.log('Cron job triggered: Sending notifications every 3 hours');
  await sendNotifications();
});

// Start the server
app.listen(PORT, '0.0.0.0', async () => {
  console.log(`Server is running on port ${PORT}`);
  // Trigger notifications immediately on deployment
  console.log('Triggering notifications on deployment...');
  await sendNotifications();
  
});
